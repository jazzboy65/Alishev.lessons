package AdvancedJava.anotation;

/**
 * Если мы реализуем анализатор исходного кода, можно создать свои аннотации,
 * чтобы их можно было использовать в коде и тем самым передавать дополнительную
 * информацию об этом коде (метаданные)
 *
 * Если мы реализуем свою библиотеку или фреймворк, можно создать свои аннотации,
 * чтобы пользователь с помощью них взаимодействовал с вашей библиотекой или
 * фреймворком (например Spring Framework)
 * В этом сценарии активно используется рефлексия
 *
 * Создание аннотации:
 * public @interface MyAnnotation {
 * }
 * Использование: @MyAnnotation
 * public class Test {
 * }
 *
 * Поля (элементы) аннотаций
 *
 * Объявляются как методы:
 * public @interface Author {
 *     String name();
 *     int dateOfBirth();
 * }
 * Но используются как поля: @Author(name = "King",dateOfBirth = 1947)
 * public class Test {
 * }
 *
 * ЗНачения по умолчанию:
 * public @interface Author {
 *     String name() default "Some name;
 *     int dateOfBirth() default 2000;
 *     }
 * Если не указываем значение для поля, оно примет значение по умолчанию
 * * @Author()
 * public class Test {
 * }
 *
 * Аннотации аннотирующие аннотации (Лежат в java.lang.annotation):
 * 1) @Target - указывает, к чему может быть применена аннотация. Значения берутся из перечисления(enum)
 * ElementType(из того же пакета).
 * FIELD - поле
 * METHOD - метод
 * TYPE - класс, интерфейс, перечисление
 *
 * 2) @Retention - политика удержания аннотации (до какого этапа компилирования или выполнения
 * аннотация видна). Значения лежат в перечислении(enum) RetentionPolicy:
 * SOURCE - отбрасываются при компиляции. Видны только в самом исходном коде
 * (подойдет для анализаторов исходного кода)
 * CLASS - сохраняются в байт - коде, но недоступные во время работы программы
 * RUNTIME - сохраняются в байт-коде и доступны во время работы программы (с помощью рефлексии)
 *
 *
 */

public class InfoCreateMyAnnotation {
}
